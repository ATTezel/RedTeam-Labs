Lab06 â€“ Dirty COW (CVE-2016-5195) Local Privilege Escalation Exploit
ğŸ“Œ Description
In this lab, we exploited the Dirty COW vulnerability (CVE-2016-5195), a well-known race condition in the Linux kernel that allows an unprivileged user to gain write access to read-only memory mappings. This vulnerability enables local privilege escalation by modifying sensitive files like /etc/passwd.

ğŸ¯ Target System
Operating System: Kali Linux 2025.1c (x64)

Kernel: Vulnerable to Dirty COW

Tool Used: dirty.c exploit script from firefart

Privileges Escalated To: root

ğŸš€ Exploitation Steps
ğŸ“ Shared folder setup: Transferred dirty.c into the VM via VirtualBox Shared Folder.

ğŸ”§ Compile the exploit:

bash
Copy
Edit
gcc -pthread dirty.c -o dirty -lcrypt
â–¶ï¸ Execute the exploit:

bash
Copy
Edit
./dirty
Chose a new password for the firefart user.

Modified the /etc/passwd file to include a new root-privileged user.

ğŸ” Manual correction (when needed):
If su firefart failed due to incomplete entry:

bash
Copy
Edit
sudo nano /etc/passwd
Then manually confirmed or corrected the firefart entry.

ğŸ”“ Root Access:

bash
Copy
Edit
su firefart
whoami  # â†’ root
id      # â†’ uid=0(root)
âœ… Clean up:
After successful privilege escalation, restored the original /etc/passwd:

bash
Copy
Edit
mv /tmp/passwd.bak /etc/passwd
ğŸ“¸ Screenshots
Step	Description	Screenshot
1	Compiled dirty.c and ran the exploit	![Compile and run](URL1)
2	Root shell obtained via su firefart	![Root shell](URL2)
3	Verified UID=0 and restored passwd	![Cleanup](URL3)

Replace URL1, URL2, URL3 with your actual GitHub image URLs.

ğŸ§  What I Learned
How race conditions in kernel memory handling can lead to privilege escalation.

How /etc/passwd stores user information and how modifying it can grant root.

The importance of restoring system integrity after exploitation.

The value of manual fallback editing when the exploit doesn't fully succeed automatically.

How to handle high CPU usage and recover from system freeze during exploitation.

